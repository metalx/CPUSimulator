
LDA 0 0 63//save a large number
SRC 0 8 L L
STR 0 0 63
LDX 0 63
AIR 0 1
STR 0 0 62//save start X0 pointer into 62
LDA 3 0 21//counter
LDA 2 0 0
LDA 0 1 1//X0++ START//loop 1:input numbers
STR 0 0 63
LDX 0 63//X0++ END
LDA 0 0 10
MUL 0 2
IN 0 0
STR 0 1 0
AMR 1 1 0
STR 1 1 0
LDR 2 1 0
CHK 0 0
JNE 0 0 13
STR 2 1 63//backup
LDA 2 0 0
SOB 3 0 10
LDR 2 1 0//Store last number(comparing number)
LDX 0 62//set X0 TO START POINTER
LDA 3 0 20//counter
STR 2 0 63//loop 2:get differences
LDR 1 0 63
SMR 1 1 0//the comparing number minus number in current pointer
STR 1 1 0//put result back into memory
LDA 0 1 1//X0++ start
STR 0 0 63
LDX 0 63//X0++ end
SOB 3 0 28
LDX 0 62
LDA 3 0 20//counter
LDR 2 1 0//loop 3:get abs
SRC 2 15 R L//get the highest bit
LDR 1 1 0//put the number in r1
JZ 2 0 44//if positive then jump
NOT 1//negtive branch
AIR 1 1//negtive branch end
STR 1 1 0//put back into memory
LDA 0 1 1//X0++ start
STR 0 0 63
LDX 0 63//X0++ end
SOB 3 0 38
LDX 0 62
LDA 3 0 19//counter
LDA 2 1 0//save the first index into r2
LDA 0 1 1//X0++ start//loop 4:comparision and find the smallest result
STR 0 0 63
LDX 0 63//X0++ end
LDR 1 1 0
STR 2 0 63
SMR 1 0 63 I
SRC 1 15 R L//comparision
JZ 1 0 61//if the former one is smaller then do nothing
LDA 2 1 0//branch:if the current one is smaller, then replace the former index
SOB 3 0 52
STR 2 0 63//store the smallest number's address into memory 63
LDR 2 1 1
LDX 0 63
LDR 1 1 63//get the original number from backup memory
OUT 1 1//output the number
OUT 2 1//output the index
